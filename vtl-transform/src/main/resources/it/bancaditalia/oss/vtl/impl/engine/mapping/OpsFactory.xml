<?xml version="1.0"?>
<!--

    Copyright Â© 2020 Banca D'Italia

    Licensed under the EUPL, Version 1.2 (the "License");
    You may not use this work except in compliance with the
    License.
    You may obtain a copy of the License at:

    https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/2020-03/EUPL-1.2%20EN.txt

    Unless required by applicable law or agreed to in
    writing, software distributed under the License is
    distributed on an "AS IS" basis,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
    express or implied.

    See the License for the specific language governing
    permissions and limitations under the License.

-->
<parserconfig xmlns="http://oss.bancaditalia.it/vtl">
	<package>it.bancaditalia.oss.vtl.impl.transform</package>
	<tokenset name="Duration" class="it.bancaditalia.oss.vtl.impl.types.data.Frequency">
		<tokenmapping name="A" value="A" />
		<tokenmapping name="S" value="S" />
		<tokenmapping name="Q" value="Q" />
		<tokenmapping name="M" value="M" />
		<tokenmapping name="W" value="W" />
		<tokenmapping name="D" value="D" />
	</tokenset>

	<tokenset name="ChronoField" class="it.bancaditalia.oss.vtl.impl.types.operators.TimeFieldOperator">
		<tokenmapping name="YEAR_OP" value="YEAR" />
		<tokenmapping name="MONTH_OP" value="MONTH" />
		<tokenmapping name="DAYOFMONTH" value="DAY_MONTH" />
		<tokenmapping name="DAYOFYEAR" value="DAY_YEAR" />
	</tokenset>

	<tokenset name="ExistsInMode" class="it.bancaditalia.oss.vtl.impl.transform.bool.ExistsInTransformation$ExistsInMode">
		<tokenmapping name="ALL" value="ALL" />
		<tokenmapping name="TRUE" value="TRUE" />
		<tokenmapping name="FALSE" value="FALSE" />
	</tokenset>

	<tokenset name="HierarchyMode" class="it.bancaditalia.oss.vtl.impl.transform.aggregation.HierarchyTransformation$HierarchyMode">
		<tokenmapping name="NON_NULL" value="NON_NULL" />
		<tokenmapping name="NON_ZERO" value="NON_ZERO" />
		<tokenmapping name="PARTIAL_NULL" value="PARTIAL_NULL" />
		<tokenmapping name="PARTIAL_ZERO" value="PARTIAL_ZERO" />
		<tokenmapping name="ALWAYS_NULL" value="ALWAYS_NULL" />
		<tokenmapping name="ALWAYS_ZERO" value="ALWAYS_ZERO" />
	</tokenset>

	<tokenset name="HierarchyInput" class="it.bancaditalia.oss.vtl.impl.transform.aggregation.HierarchyTransformation$HierarchyInput">
		<tokenmapping name="DATASET" value="DATASET" />
		<tokenmapping name="RULE" value="RULE" />
		<tokenmapping name="RULE_PRIORITY" value="RULE_PRIORITY" />
	</tokenset>

	<tokenset name="HierarchyOutput" class="it.bancaditalia.oss.vtl.impl.transform.aggregation.HierarchyTransformation$HierarchyOutput">
		<tokenmapping name="COMPUTED" value="COMPUTED" />
		<tokenmapping name="ALL" value="ALL" />
	</tokenset>

	<tokenset name="ValidationInput" class="it.bancaditalia.oss.vtl.impl.transform.ops.CheckHierarchyTransformation$Input">
		<tokenmapping name="DATASET" value="DATASET" />
		<tokenmapping name="RULE" value="RULE" />
		<tokenmapping name="RULE_PRIORITY" value="RULE_PRIORITY" />
	</tokenset>

	<tokenset name="ValidationOutput" class="it.bancaditalia.oss.vtl.impl.transform.ops.CheckHierarchyTransformation$Output">
		<tokenmapping name="COMPUTED" value="COMPUTED" />
		<tokenmapping name="ALL" value="ALL" />
	</tokenset>

	<tokenset name="WindowDirection" class="it.bancaditalia.oss.vtl.model.transform.analytic.LimitCriterion$LimitDirection">
		<tokenmapping name="PRECEDING" value="PRECEDING" />
		<tokenmapping name="FOLLOWING" value="FOLLOWING" />
	</tokenset>

	<tokenset name="GroupingMode" class="it.bancaditalia.oss.vtl.model.transform.GroupingClause$GroupingMode">
		<tokenmapping name="BY" value="GROUP_BY" />
		<tokenmapping name="EXCEPT" value="GROUP_EXCEPT" />
		<tokenmapping name="ALL" value="GROUP_ALL" />
	</tokenset>

	<tokenset name="OffsetDirection" class="it.bancaditalia.oss.vtl.impl.transform.aggregation.OffsetTransformation$OffsetDirection">
		<tokenmapping name="LAG" value="LAG" />
		<tokenmapping name="LEAD" value="LEAD" />
	</tokenset>

	<tokenset name="WindowRangeType" class="it.bancaditalia.oss.vtl.model.transform.analytic.WindowCriterion$LimitType">
		<tokenmapping name="RANGE" value="RANGE" />
		<tokenmapping name="DATA" value="DATAPOINTS" />
	</tokenset>

	<tokenset name="OrderingMethod" class="it.bancaditalia.oss.vtl.model.transform.analytic.SortCriterion$SortingMethod">
		<tokenmapping name="ASC" value="ASC" />
		<tokenmapping name="DESC" value="DESC" />
	</tokenset>

	<tokenset name="ValueDomainType" class="it.bancaditalia.oss.vtl.impl.types.domain.Domains">
		<tokenmapping name="STRING" value="STRING" />
		<tokenmapping name="INTEGER" value="INTEGER" />
		<tokenmapping name="NUMBER" value="NUMBER" />
		<tokenmapping name="BOOLEAN" value="BOOLEAN" />
		<tokenmapping name="DATE" value="DATE" />
		<tokenmapping name="TIME" value="TIME" />
		<tokenmapping name="TIME_PERIOD" value="TIME_PERIOD" />
		<tokenmapping name="DURATION" value="DURATION" />
	</tokenset>

	<tokenset name="PeriodDelimiter" class="it.bancaditalia.oss.vtl.impl.transform.time.TimeAggTransformation$PeriodDelimiter">
		<tokenmapping name="FIRST" value="FIRST" />
		<tokenmapping name="LAST" value="LAST" />
	</tokenset>

	<tokenset name="StringOperator" class="it.bancaditalia.oss.vtl.impl.transform.string.StringUnaryTransformation$StringOperator">
		<tokenmapping name="TRIM" value="TRIM" />
		<tokenmapping name="LTRIM" value="LTRIM" />
		<tokenmapping name="RTRIM" value="RTRIM" />
		<tokenmapping name="UCASE" value="UCASE" />
		<tokenmapping name="LCASE" value="LCASE" />
	</tokenset>

	<tokenset name="AggregateOperator" class="it.bancaditalia.oss.vtl.impl.types.operators.AggregateOperator">
		<tokenmapping name="SUM" value="SUM" />
		<tokenmapping name="COUNT" value="COUNT" />
		<tokenmapping name="MAX" value="MAX" />
		<tokenmapping name="MIN" value="MIN" />
		<tokenmapping name="MEDIAN" value="MEDIAN" />
		<tokenmapping name="AVG" value="AVG" />
		<tokenmapping name="VAR_POP" value="VAR_POP" />
		<tokenmapping name="VAR_SAMP" value="VAR_SAMP" />
		<tokenmapping name="STDDEV_POP" value="STDDEV_POP" />
		<tokenmapping name="STDDEV_SAMP" value="STDDEV_SAMP" />
	</tokenset>

	<tokenset name="AnalyticOperator" class="it.bancaditalia.oss.vtl.impl.types.operators.AnalyticOperator">
		<tokenmapping name="SUM" value="SUM" />
		<tokenmapping name="COUNT" value="COUNT" />
		<tokenmapping name="MAX" value="MAX" />
		<tokenmapping name="MIN" value="MIN" />
		<tokenmapping name="MEDIAN" value="MEDIAN" />
		<tokenmapping name="AVG" value="AVG" />
		<tokenmapping name="VAR_POP" value="VAR_POP" />
		<tokenmapping name="VAR_SAMP" value="VAR_SAMP" />
		<tokenmapping name="STDDEV_POP" value="STDDEV_POP" />
		<tokenmapping name="STDDEV_SAMP" value="STDDEV_SAMP" />
		<tokenmapping name="FIRST_VALUE" value="FIRST_VALUE" />
		<tokenmapping name="LAST_VALUE" value="LAST_VALUE" />
	</tokenset>

	<tokenset name="NumericUnaryOperator" class="it.bancaditalia.oss.vtl.impl.transform.number.NumericUnaryTransformation$NumericOperator">
		<tokenmapping name="PLUS" value="UNARY_PLUS" />
		<tokenmapping name="MINUS" value="UNARY_MINUS" />
		<tokenmapping name="CEIL" value="CEIL" />
		<tokenmapping name="FLOOR" value="FLOOR" />
		<tokenmapping name="ABS" value="ABS" />
		<tokenmapping name="EXP" value="EXP" />
		<tokenmapping name="LN" value="LN" />
		<tokenmapping name="SQRT" value="SQRT" />
	</tokenset>

	<tokenset name="ComparisonOperator" class="it.bancaditalia.oss.vtl.impl.types.operators.ComparisonOperator">
		<tokenmapping name="MT" value="GT" />
		<tokenmapping name="ME" value="GE" />
		<tokenmapping name="LE" value="LE" />
		<tokenmapping name="LT" value="LT" />
		<tokenmapping name="EQ" value="EQ" />
		<tokenmapping name="NEQ" value="NE" />
	</tokenset>

	<tokenset name="SetOperator" class="it.bancaditalia.oss.vtl.impl.transform.ops.SetTransformation$SetOperator">
		<tokenmapping name="UNION" value="UNION" />
		<tokenmapping name="INTERSECT" value="INTERSECT" />
		<tokenmapping name="SETDIFF" value="SETDIFF" />
		<tokenmapping name="SYMDIFF" value="SYMDIFF" />
	</tokenset>

	<tokenset name="DatasetOperator" class="it.bancaditalia.oss.vtl.impl.transform.time.FlowStockTransformation$DatasetOperator">
		<tokenmapping name="FLOW_TO_STOCK" value="FLOW_TO_STOCK" />
		<tokenmapping name="STOCK_TO_FLOW" value="STOCK_TO_FLOW" />
	</tokenset>

	<tokenset name="InOperator" class="it.bancaditalia.oss.vtl.impl.transform.bool.InclusionTransformation$InOperator">
		<tokenmapping name="IN" value="IN" />
		<tokenmapping name="NOT_IN" value="NOTIN" />
	</tokenset>

	<tokenset name="ArithmeticOperator" class="it.bancaditalia.oss.vtl.impl.types.operators.ArithmeticOperator">
		<tokenmapping name="PLUS" value="SUM" />
		<tokenmapping name="MINUS" value="DIFF" />
		<tokenmapping name="MUL" value="MULT" />
		<tokenmapping name="DIV" value="DIV" />
		<tokenmapping name="MOD" value="MOD" />
		<tokenmapping name="POWER" value="POWER" />
		<tokenmapping name="LOG" value="LOG" />
	</tokenset>

	<tokenset name="NumericIntOperator" class="it.bancaditalia.oss.vtl.impl.types.operators.NumericIntOperator">
		<tokenmapping name="ROUND" value="ROUND" />
		<tokenmapping name="TRUNC" value="TRUNC" />
		<tokenmapping name="RANDOM" value="RANDOM" />
	</tokenset>

	<tokenset name="BooleanOperator" class="it.bancaditalia.oss.vtl.impl.transform.bool.BooleanTransformation$BooleanBiOperator">
		<tokenmapping name="AND" value="AND" />
		<tokenmapping name="OR" value="OR" />
		<tokenmapping name="XOR" value="XOR" />
	</tokenset>

	<tokenset name="JoinOperator" class="it.bancaditalia.oss.vtl.impl.transform.ops.JoinTransformation$JoinOperator">
		<tokenmapping name="INNER_JOIN" value="INNER_JOIN" />
		<tokenmapping name="LEFT_JOIN" value="LEFT_JOIN" />
		<tokenmapping name="FULL_JOIN" value="FULL_JOIN" />
		<tokenmapping name="CROSS_JOIN" value="CROSS_JOIN" />
	</tokenset>

	<tokenset name="FillMode" class="it.bancaditalia.oss.vtl.impl.transform.time.FillTimeSeriesTransformation$FillMode">
		<tokenmapping name="ALL" value="ALL" />
		<tokenmapping name="SINGLE" value="SINGLE" />
	</tokenset>

	<tokenset name="CheckOutput" class="it.bancaditalia.oss.vtl.impl.transform.ops.CheckTransformation$CheckOutput">
		<tokenmapping name="ALL" value="ALL" />
		<tokenmapping name="INVALID" value="INVALID" />
	</tokenset>

	<tokenset name="ValidationOutput" class="it.bancaditalia.oss.vtl.impl.transform.ops.CheckHierarchyTransformation$Output">
		<tokenmapping name="INVALID" value="INVALID" />
		<tokenmapping name="ALL" value="ALL" />
		<tokenmapping name="ALL_MEASURES" value="ALL_MEASURES" />
	</tokenset>
	
	<recursivecontexts>
		<context name="AggregateFunctionsContext" />
		<context name="AggregateFunctionsComponentsContext" />
		<context name="AnalyticFunctionsContext" />
		<context name="AnalyticFunctionsComponentsContext" />
		<context name="CompIdContext" />
		<context name="ComparisonFunctionsContext" />
		<context name="ComparisonFunctionsComponentsContext" />
		<context name="ConditionalFunctionsContext" />
		<context name="ConditionalFunctionsComponentsContext" />
		<context name="DatasetClauseContext" />
		<context name="FunctionsExpressionContext" />
		<context name="FunctionsExpressionCompContext" />
		<context name="GenericFunctionsContext" />
		<context name="GenericFunctionsComponentsContext" />
		<context name="HavingClauseContext" />
		<context name="ImbalanceExprContext" />
		<context name="JoinFunctionsContext" />
		<context name="JoinApplyClauseContext" />
		<context name="NumericFunctionsContext" />
		<context name="NumericFunctionsComponentsContext" />
		<context name="ParameterContext" />
		<context name="ParameterComponentContext" />
		<context name="ParenthesisExprCompContext" />
		<context name="ParenthesisExprContext" />
		<context name="SetFunctionsContext" />
		<context name="SimpleScalarContext" />
		<context name="StringFunctionsContext" />
		<context name="HierarchyFunctionsContext" />
		<context name="StringFunctionsComponentsContext" />
		<context name="TimeFunctionsContext" />
		<context name="TimeFunctionsComponentsContext" />
		<context name="ValidationFunctionsContext" />
		<context name="VarIdExprContext" />
	</recursivecontexts>
	
	<mapping to="time.CurrentDateOperand">
		<from>CurrentDateAtom</from>
	</mapping>

	<mapping to="ops.CheckHierarchyTransformation">
		<from>ValidateHRruleset</from>
		<exprparam name="op" />
		<aliasparam name="hrName" />
		<nestedparam name="conditionClause">
			<listparam name="componentID">
				<aliasparam />
			</listparam>
		</nestedparam>
		<aliasparam name="componentID" />
		<tokensetparam name="validationMode" tokenset="HierarchyMode" />
		<tokensetparam name="inputMode" tokenset="ValidationInput" />
		<tokensetparam name="validationOutput" tokenset="ValidationOutput" />
	</mapping>

	<mapping to="ops.CheckDataPointTransformation">
		<from>ValidateDPruleset</from>
		<exprparam name="op" />
		<aliasparam name="dpName" />
		<listparam name="componentID">
			<aliasparam />
		</listparam>
		<tokensetparam name="validationOutput" tokenset="ValidationOutput" />
	</mapping>

	<mapping to="aggregation.HierarchyTransformation">
		<from>HierarchyOperators</from>
		<exprparam name="expr" />
		<aliasparam name="hrName" />
		<nestedparam name="conditionClause">
			<listparam name="componentID">
				<aliasparam />
			</listparam>
		</nestedparam>
		<aliasparam name="ruleComponent" />
		<tokensetparam name="validationMode" tokenset="HierarchyMode" />
		<tokensetparam name="inputModeHierarchy" tokenset="HierarchyInput" />
		<tokensetparam name="outputModeHierarchy" tokenset="HierarchyOutput" />
	</mapping>

	<mapping to="aggregation.SimpleAnalyticTransformation">
		<from>AnSimpleFunction</from>
		<tokensetparam name="op" tokenset="AnalyticOperator" />
		<exprparam name="expr" />
		<nestedparam name="partitionByClause">
			<listparam name="componentID">
				<aliasparam />
			</listparam>
		</nestedparam>
		<nestedparam name="orderByClause">
			<listparam name="orderByItem">
				<customparam class="it.bancaditalia.oss.vtl.impl.transform.aggregation.AnalyticTransformation$OrderByItem">
					<aliasparam name="componentID" />
					<tokensetparam tokenset="OrderingMethod" />
				</customparam>
			</listparam>
		</nestedparam>
		<customparam name="windowingClause" class="it.bancaditalia.oss.vtl.impl.transform.util.WindowCriterionImpl">
			<tokensetparam tokenset="WindowRangeType" />
			<customparam name="from_" class="it.bancaditalia.oss.vtl.impl.transform.util.LimitClause">
				<tokensetparam name="dir" tokenset="WindowDirection" />
				<valueparam />
			</customparam>
			<customparam name="to_" class="it.bancaditalia.oss.vtl.impl.transform.util.LimitClause">
				<tokensetparam name="dir" tokenset="WindowDirection" />
				<valueparam />
			</customparam>
		</customparam>
	</mapping>

	<mapping to="aggregation.OffsetTransformation">
		<from>LagOrLeadAn</from>
		<tokensetparam name="op" tokenset="OffsetDirection" />
		<exprparam name="expr" />
		<valueparam name="signedInteger" />
		<valueparam name="defaultValue" />
		<nestedparam name="partitionByClause">
			<listparam name="componentID">
				<aliasparam />
			</listparam>
		</nestedparam>
		<nestedparam name="orderByClause">
			<listparam name="orderByItem">
				<customparam class="it.bancaditalia.oss.vtl.impl.transform.aggregation.AnalyticTransformation$OrderByItem">
					<aliasparam name="componentID" />
					<tokensetparam tokenset="OrderingMethod" />
				</customparam>
			</listparam>
		</nestedparam>
	</mapping>

	<mapping to="aggregation.OffsetTransformation">
		<from>LagOrLeadAnComponent</from>
		<tokensetparam name="op" tokenset="OffsetDirection" />
		<exprparam name="exprComponent" />
		<valueparam name="signedInteger" />
		<valueparam name="defaultValue" />
		<nestedparam name="partitionByClause">
			<listparam name="componentID">
				<aliasparam />
			</listparam>
		</nestedparam>
		<nestedparam name="orderByClause">
			<listparam name="orderByItem">
				<customparam class="it.bancaditalia.oss.vtl.impl.transform.aggregation.AnalyticTransformation$OrderByItem">
					<aliasparam name="componentID" />
					<tokensetparam tokenset="OrderingMethod" />
				</customparam>
			</listparam>
		</nestedparam>
	</mapping>

	<mapping to="aggregation.RatioToReportTransformation">
		<from>RatioToReportAn</from>
		<exprparam name="expr" />
		<nestedparam name="partitionByClause">
			<listparam name="componentID">
				<aliasparam />
			</listparam>
		</nestedparam>
	</mapping>

	<mapping to="aggregation.RatioToReportTransformation">
		<from>RatioToReportAnComponent</from>
		<exprparam name="exprComponent" />
		<nestedparam name="partitionByClause">
			<listparam name="componentID">
				<aliasparam />
			</listparam>
		</nestedparam>
	</mapping>

	<mapping to="aggregation.SimpleAnalyticTransformation">
		<from>AnSimpleFunctionComponent</from>
		<tokensetparam name="op" tokenset="AnalyticOperator" />
		<exprparam name="exprComponent" />
		<nestedparam name="partitionByClause">
			<listparam name="componentID">
				<aliasparam />
			</listparam>
		</nestedparam>
		<nestedparam name="orderByClause">
			<listparam name="orderByItem">
				<customparam class="it.bancaditalia.oss.vtl.impl.transform.aggregation.AnalyticTransformation$OrderByItem">
					<aliasparam name="componentID" />
					<tokensetparam tokenset="OrderingMethod" />
				</customparam>
			</listparam>
		</nestedparam>
		<customparam name="windowingClause" class="it.bancaditalia.oss.vtl.impl.transform.util.WindowCriterionImpl">
			<tokensetparam tokenset="WindowRangeType" />
			<customparam name="from_" class="it.bancaditalia.oss.vtl.impl.transform.util.LimitClause">
				<tokensetparam name="dir" tokenset="WindowDirection" />
				<valueparam />
			</customparam>
			<customparam name="to_" class="it.bancaditalia.oss.vtl.impl.transform.util.LimitClause">
				<tokensetparam name="dir" tokenset="WindowDirection" />
				<valueparam />
			</customparam>
		</customparam>
	</mapping>

	<mapping to="aggregation.RankTransformation">
		<from>RankAnComponent</from>
		<nestedparam name="partitionByClause">
			<listparam name="componentID">
				<aliasparam />
			</listparam>
		</nestedparam>
		<nestedparam name="orderByClause">
			<listparam name="orderByItem">
				<customparam class="it.bancaditalia.oss.vtl.impl.transform.aggregation.AnalyticTransformation$OrderByItem">
					<aliasparam name="componentID" />
					<tokensetparam tokenset="OrderingMethod" />
				</customparam>
			</listparam>
		</nestedparam>
	</mapping>

	<mapping to="aggregation.AggregateTransformation">
		<from>AggrDataset</from>
		<tokensetparam name="op" tokenset="AggregateOperator" />
		<exprparam name="expr" />
		<nestedparam name="groupingClause" type="groupby">
			<customparam class="it.bancaditalia.oss.vtl.impl.transform.GroupingClauseImpl">
				<case>
					<tokens ordinal="2">
						<value>BY</value>
						<value>EXCEPT</value>
					</tokens>
					<tokensetparam name="op" tokenset="GroupingMode" />
					<listparam name="componentID">
						<aliasparam />
					</listparam>
					<valueparam name="STRING_CONSTANT" />
				</case>
				<case>
					<tokens ordinal="2">
						<value>ALL</value>
					</tokens>
					<tokensetparam ordinal="2" tokenset="GroupingMode" />
					<nullparam />
					<valueparam name="STRING_CONSTANT" />
				</case>
			</customparam>
		</nestedparam>
		<exprparam name="havingClause" />
	</mapping>

	<mapping to="aggregation.AggregateTransformation">
		<from>AggrComp</from>
		<tokensetparam name="op" tokenset="AggregateOperator" />
		<exprparam name="exprComponent" />
		<nullparam type="groupby" />
		<nullparam />
	</mapping>

	<mapping to="aggregation.AggregateTransformation">
		<from>CountAggrComp</from>
		<nullparam type="groupby" />
		<nullparam />
	</mapping>

	<mapping to="dataset.AggrClauseTransformation">
		<from>AggrClause</from>
		<tokens name="groupingClause">
			<value>BY</value>
			<value>EXCEPT</value>
		</tokens>
		<nestedparam name="aggregateClause">
			<listparam name="aggrFunctionClause">
				<customparam class="it.bancaditalia.oss.vtl.impl.transform.dataset.AggrClauseTransformation$AggrClauseItem">
					<roleparam name="componentRole" />
					<aliasparam name="componentID" />
					<exprparam name="aggrOperators" />
				</customparam>
			</listparam>
		</nestedparam>
		<nestedparam name="groupingClause" type="groupby">
			<customparam class="it.bancaditalia.oss.vtl.impl.transform.GroupingClauseImpl">
				<tokensetparam name="op" tokenset="GroupingMode" />
				<listparam name="componentID">
					<aliasparam />
				</listparam>
				<valueparam name="STRING_CONSTANT" />
			</customparam>
		</nestedparam>
		<exprparam name="havingClause" />
	</mapping>

	<mapping to="dataset.AggrClauseTransformation">
		<from>AggrClause</from>
		<tokens name="groupingClause">
			<value>ALL</value>
		</tokens>
		<nestedparam name="aggregateClause">
			<listparam name="aggrFunctionClause">
				<customparam class="it.bancaditalia.oss.vtl.impl.transform.dataset.AggrClauseTransformation$AggrClauseItem">
					<roleparam name="componentRole" />
					<aliasparam name="componentID" />
					<exprparam name="aggrOperators" />
				</customparam>
			</listparam>
		</nestedparam>
		<nestedparam name="groupingClause" type="groupby">
			<customparam class="it.bancaditalia.oss.vtl.impl.transform.GroupingClauseImpl">
				<tokensetparam ordinal="2" tokenset="GroupingMode" />
				<nullparam />
				<valueparam name="STRING_CONSTANT" />
			</customparam>
		</nestedparam>
		<exprparam name="havingClause" />
	</mapping>

	<mapping to="dataset.KeepClauseTransformation">
		<from>KeepOrDropClause</from>
		<tokens name="op">
			<value>KEEP</value>
		</tokens>
		<listparam name="componentID">
			<aliasparam />
		</listparam>
	</mapping>

	<mapping to="dataset.DropClauseTransformation">
		<from>KeepOrDropClause</from>
		<tokens name="op">
			<value>DROP</value>
		</tokens>
		<listparam name="componentID">
			<aliasparam />
		</listparam>
	</mapping>

	<mapping to="dataset.CalcClauseTransformation">
		<from>CalcClause</from>
		<listparam name="calcClauseItem">
			<exprparam />
		</listparam>
	</mapping>

	<mapping to="dataset.CalcClauseTransformation$CalcClauseItem">
		<from>CalcClauseItem</from>
		<roleparam name="componentRole" />
		<aliasparam name="componentID" />
		<exprparam name="exprComponent" />
	</mapping>

	<mapping to="ops.JoinTransformation">
		<from>JoinExpr</from>
		<tokens name="joinKeyword">
			<value>INNER_JOIN</value>
			<value>LEFT_JOIN</value>
		</tokens>
		<tokensetparam name="joinKeyword" tokenset="JoinOperator" />
		<nestedparam name="joinClause">
			<listparam name="joinClauseItem">
				<customparam class="it.bancaditalia.oss.vtl.impl.transform.ops.JoinTransformation$JoinOperand">
					<exprparam name="expr" />
					<aliasparam name="alias" />
				</customparam>
			</listparam>
			<listparam name="componentID">
				<aliasparam />
			</listparam>
		</nestedparam>
		<nestedparam name="joinBody">
			<exprparam name="filterClause" />
			<exprparam name="joinApplyClause" />
			<exprparam name="calcClause" />
			<exprparam name="aggrClause" />
			<exprparam name="keepOrDropClause" />
			<exprparam name="renameClause" />
		</nestedparam>
	</mapping>

	<mapping to="ops.JoinTransformation">
		<from>JoinExpr</from>
		<tokens name="joinKeyword">
			<value>FULL_JOIN</value>
			<value>CROSS_JOIN</value>
		</tokens>
		<tokensetparam name="joinKeyword" tokenset="JoinOperator" />
		<nestedparam name="joinClauseWithoutUsing">
			<listparam name="joinClauseItem">
				<customparam class="it.bancaditalia.oss.vtl.impl.transform.ops.JoinTransformation$JoinOperand">
					<exprparam name="expr" />
					<aliasparam name="alias" />
				</customparam>
			</listparam>
			<nullparam />
		</nestedparam>
		<nestedparam name="joinBody">
			<exprparam name="filterClause" />
			<exprparam name="joinApplyClause" />
			<exprparam name="calcClause" />
			<exprparam name="aggrClause" />
			<exprparam name="keepOrDropClause" />
			<exprparam name="renameClause" />
		</nestedparam>
	</mapping>

	<mapping to="ops.SetTransformation">
		<from>UnionAtom</from>
		<tokensetparam tokenset="SetOperator" />
		<listparam name="expr">
			<exprparam />
		</listparam>
	</mapping>

	<mapping to="ops.SetTransformation">
		<from>IntersectAtom</from>
		<tokensetparam tokenset="SetOperator" />
		<listparam name="expr">
			<exprparam />
		</listparam>
	</mapping>

	<mapping to="ops.SetTransformation">
		<from>SetOrSYmDiffAtom</from>
		<tokensetparam tokenset="SetOperator" />
		<listparam name="expr">
			<exprparam />
		</listparam>
	</mapping>

	<mapping to="ops.JoinTransformation$JoinOperand">
		<from>JoinClauseItem</from>
		<exprparam name="expr" />
		<aliasparam name="alias" />
	</mapping>

	<mapping to="dataset.BracketTransformation">
		<from>ClauseExpr</from>
		<exprparam name="dataset" />
		<exprparam name="clause" />
		<nullparam />
	</mapping>

	<mapping to="time.PeriodIndicatorTransformation">
		<from>PeriodAtom</from>
		<from>PeriodAtomComponent</from>
		<exprparam name="expr|exprComponent" />
	</mapping>

	<mapping to="bool.ConditionalTransformation">
		<from>IfExpr</from>
		<from>IfExprComp</from>
		<exprparam name="conditionalExpr" />
		<exprparam name="thenExpr" />
		<exprparam name="elseExpr" />
	</mapping>

	<mapping to="bool.CaseWhenTransformation">
		<from>CaseExpr</from>
		<from>CaseExprComp</from>
		<listparam name="condExpr">
			<exprparam />
		</listparam>
		<listparam name="thenExpr">
			<exprparam />
		</listparam>
		<exprparam name="elseExpr" />
	</mapping>

	<mapping to="bool.BetweenTransformation">
		<from>BetweenAtom</from>
		<from>BetweenAtomComponent</from>
		<exprparam name="op" />
		<exprparam name="from_" />
		<exprparam name="to_" />
	</mapping>

	<mapping to="time.FillTimeSeriesTransformation">
		<from>FillTimeAtom</from>
		<exprparam name="expr" />
		<tokensetparam tokenset="FillMode" name="op" />
	</mapping>

	<mapping to="time.DateAddTransformation">
		<from>DateAddAtom</from>
		<from>DateAddAtomComponent</from>
		<exprparam name="op" />
		<exprparam name="shiftNumber" />
		<exprparam name="periodInd" />
	</mapping>

	<mapping to="time.DateDiffTransformation">
		<from>DateDiffAtom</from>
		<from>DateDiffAtomComponent</from>
		<exprparam name="dateFrom" />
		<exprparam name="dateTo" />
	</mapping>

	<mapping to="time.TimeShiftTransformation">
		<from>TimeShiftAtom</from>
		<exprparam name="expr" />
		<valueparam name="signedInteger" />
	</mapping>

	<mapping to="time.TimeAggTransformation">
		<from>TimeAggAtom</from>
		<from>TimeAggAtomComponent</from>
		<nestedparam name="op">
			<exprparam name="expr|exprComponent" />
		</nestedparam>
		<stringparam name="periodIndTo" />
		<stringparam name="periodIndFrom" />
		<tokensetparam name="delim" tokenset="PeriodDelimiter" />
	</mapping>

	<mapping to="dataset.BracketTransformation">
		<from>MembershipExpr</from>
		<exprparam name="expr" />
		<nullparam />
		<aliasparam name="simpleComponentId" />
	</mapping>

	<mapping to="dataset.SubspaceClauseTransformation">
		<from>SubspaceClause</from>
		<mapparam name="subspaceClauseItem">
			<key>
				<aliasparam name="componentID" />
			</key>
			<value>
				<valueparam name="scalarItem" />
			</value>
		</mapparam>
	</mapping>

	<mapping to="dataset.RenameClauseTransformation">
		<from>RenameClause</from>
		<mapparam name="renameClauseItem">
			<key>
				<aliasparam name="fromName" />
			</key>
			<value>
				<aliasparam name="toName" />
			</value>
		</mapparam>
	</mapping>

	<mapping to="dataset.FilterClauseTransformation">
		<from>FilterClause</from>
		<exprparam name="exprComponent" />
	</mapping>

	<mapping to="ops.CallTransformation">
		<from>CallComponent</from>
		<aliasparam name="operatorID" />
		<listparam name="parameterComponent">
			<exprparam />
		</listparam>
	</mapping>

	<mapping to="ops.CallTransformation">
		<from>CallDataset</from>
		<aliasparam name="operatorID" />
		<listparam name="parameter">
			<exprparam />
		</listparam>
	</mapping>

	<mapping to="string.StringUnaryTransformation">
		<from>UnaryStringFunction</from>
		<from>UnaryStringFunctionComponent</from>
		<tokens name="op">
			<value>TRIM</value>
			<value>LTRIM</value>
			<value>RTRIM</value>
			<value>UCASE</value>
			<value>LCASE</value>
		</tokens>
		<tokensetparam tokenset="StringOperator" name="op" />
		<exprparam name="expr|exprComponent" />
	</mapping>

	<mapping to="string.StrlenTransformation">
		<from>UnaryStringFunction</from>
		<from>UnaryStringFunctionComponent</from>
		<tokens name="op">
			<value>LEN</value>
		</tokens>
		<exprparam name="expr|exprComponent" />
	</mapping>

	<mapping to="bool.ExistsInTransformation">
		<from>ExistInAtom</from>
		<exprparam name="left" />
		<exprparam name="right" />
		<tokensetparam tokenset="ExistsInMode" name="retainType" />
	</mapping>

	<mapping to="ConstantOperand">
		<from>ConstantExpr</from>
		<from>ConstantExprComp</from>
		<valueparam name="constant" />
	</mapping>

	<mapping to="ConstantOperand">
		<from>Constant</from>
		<valueparam />
	</mapping>

	<mapping to="ops.CastTransformation">
		<from>CastExprDataset</from>
		<tokens name="basicScalarType">
			<value>STRING</value>
			<value>INTEGER</value>
			<value>NUMBER</value>
			<value>BOOLEAN</value>
			<value>DATE</value>
			<value>TIME</value>
			<value>TIME_PERIOD</value>
			<value>DURATION</value>
			<value>SCALAR</value>
		</tokens>
		<exprparam name="expr" />
		<tokensetparam name="basicScalarType" tokenset="ValueDomainType" />
		<stringparam name="STRING_CONSTANT" />
	</mapping>

	<mapping to="ops.CastTransformation">
		<from>CastExprDataset</from>
		<exprparam name="expr" />
		<aliasparam name="valueDomainName" />
		<stringparam name="STRING_CONSTANT" />
	</mapping>

	<mapping to="ops.CastTransformation">
		<from>CastExprComponent</from>
		<tokens name="basicScalarType">
			<value>STRING</value>
			<value>INTEGER</value>
			<value>NUMBER</value>
			<value>BOOLEAN</value>
			<value>DATE</value>
			<value>TIME</value>
			<value>TIME_PERIOD</value>
			<value>DURATION</value>
			<value>SCALAR</value>
		</tokens>
		<exprparam name="exprComponent" />
		<tokensetparam name="basicScalarType" tokenset="ValueDomainType" />
		<stringparam name="STRING_CONSTANT" />
	</mapping>

	<mapping to="ops.CastTransformation">
		<from>CastExprComponent</from>
		<exprparam name="exprComponent" />
		<aliasparam name="valueDomainName" />
		<stringparam name="STRING_CONSTANT" />
	</mapping>

	<mapping to="number.NumericUnaryTransformation">
		<from>UnaryExpr</from>
		<from>UnaryExprComp</from>
		<tokens name="op">
			<value>PLUS</value>
			<value>MINUS</value>
		</tokens>
		<tokensetparam name="op" tokenset="NumericUnaryOperator" />
		<exprparam name="right" />
	</mapping>

	<mapping to="bool.NotTransformation">
		<from>UnaryExpr</from>
		<from>UnaryExprComp</from>
		<tokens name="op">
			<value>NOT</value>
		</tokens>
		<exprparam name="right" />
	</mapping>

	<mapping to="bool.ComparisonTransformation">
		<from>ComparisonExpr</from>
		<from>ComparisonExprComp</from>
		<tokensetparam name="comparisonOperand" tokenset="ComparisonOperator" />
		<exprparam name="left" />
		<exprparam name="right" />
	</mapping>

	<mapping to="string.InStrTransformation">
		<from>InstrAtom</from>
		<from>InstrAtomComponent</from>
		<exprparam name="expr|exprComponent" ordinal="0" />
		<exprparam name="pattern" />
		<nestedparam name="startParameter">
			<exprparam name="expr|exprComponent" />
		</nestedparam>
		<nestedparam name="occurrenceParameter">
			<exprparam name="expr|exprComponent" />
		</nestedparam>
	</mapping>

	<mapping to="string.MatchTransformation">
		<from>CharsetMatchAtom</from>
		<from>CharsetMatchAtomComponent</from>
		<exprparam name="op" />
		<exprparam name="pattern" />
	</mapping>

	<mapping to="bool.IsNullTransformation">
		<from>IsNullAtom</from>
		<from>IsNullAtomComponent</from>
		<exprparam name="expr|exprComponent" />
	</mapping>

	<mapping to="bool.NvlTransformation">
		<from>NvlAtom</from>
		<from>NvlAtomComponent</from>
		<exprparam name="left" />
		<exprparam name="right" />
	</mapping>

	<mapping to="string.ReplaceTransformation">
		<from>ReplaceAtom</from>
		<from>ReplaceAtomComponent</from>
		<exprparam name="expr|exprComponent" ordinal="0" />
		<exprparam name="param" />
		<nestedparam name="optionalExpr|optionalExprComponent">
			<exprparam name="expr|exprComponent" />
		</nestedparam>
	</mapping>

	<mapping to="string.SubstrTransformation">
		<from>SubstrAtom</from>
		<from>SubstrAtomComponent</from>
		<exprparam name="expr|exprComponent" />
		<nestedparam name="startParameter">
			<exprparam name="expr|exprComponent" />
		</nestedparam>
		<nestedparam name="endParameter">
			<exprparam name="expr|exprComponent" />
		</nestedparam>
	</mapping>

	<mapping to="time.ExtractTimeFieldTransformation">
		<from>YearAtomComponent</from>
		<from>MonthAtomComponent</from>
		<from>DayOfMonthAtomComponent</from>
		<from>DayOfYearAtomComponent</from>
		<tokensetparam ordinal="1" tokenset="ChronoField" />
		<exprparam name="exprComponent" />
	</mapping>

	<mapping to="number.ArithmeticTransformation">
		<from>ArithmeticExprOrConcat</from>
		<from>ArithmeticExprOrConcatComp</from>
		<tokens name="op">
			<value>PLUS</value>
			<value>MINUS</value>
		</tokens>
		<tokensetparam name="op" tokenset="ArithmeticOperator" />
		<exprparam name="left" />
		<exprparam name="right" />
	</mapping>

	<mapping to="number.ArithmeticTransformation">
		<from>BinaryNumeric</from>
		<from>BinaryNumericComponent</from>
		<tokens name="op">
			<value>MOD</value>
			<value>LOG</value>
			<value>POWER</value>
		</tokens>
		<tokensetparam name="op" tokenset="ArithmeticOperator" />
		<exprparam name="left" />
		<exprparam name="right" />
	</mapping>

	<mapping to="number.NumericIntTransformation">
		<from>UnaryWithOptionalNumeric</from>
		<from>UnaryWithOptionalNumericComponent</from>
		<tokens name="op">
			<value>ROUND</value>
			<value>TRUNC</value>
			<value>RANDOM</value>
		</tokens>
		<tokensetparam name="op" tokenset="NumericIntOperator" />
		<exprparam name="expr|exprComponent" />
		<nestedparam name="optionalExpr|optionalExprComponent">
			<exprparam name="expr|exprComponent" />
		</nestedparam>
	</mapping>

	<mapping to="bool.BooleanTransformation">
		<from>BooleanExpr</from>
		<from>BooleanExprComp</from>
		<tokensetparam name="op" tokenset="BooleanOperator" />
		<exprparam name="left" />
		<exprparam name="right" />
	</mapping>

	<mapping to="string.ConcatTransformation">
		<from>ArithmeticExprOrConcat</from>
		<from>ArithmeticExprOrConcatComp</from>
		<tokens name="op">
			<value>CONCAT</value>
		</tokens>
		<exprparam name="left" />
		<exprparam name="right" />
	</mapping>

	<mapping to="number.ArithmeticTransformation">
		<from>ArithmeticExpr</from>
		<from>ArithmeticExprComp</from>
		<tokensetparam name="op" tokenset="ArithmeticOperator" />
		<exprparam name="left" />
		<exprparam name="right" />
	</mapping>

	<mapping to="time.FlowStockTransformation">
		<from>FlowAtom</from>
		<tokensetparam name="op" tokenset="DatasetOperator" />
		<exprparam name="expr" />
	</mapping>

	<mapping to="bool.InclusionTransformation">
		<from>InNotInExpr</from>
		<from>InNotInExprComp</from>
		<tokensetparam name="op" tokenset="InOperator" />
		<exprparam name="left" />
		<nestedparam name="lists">
			<listparam name="scalarItem">
				<valueparam />
			</listparam>
		</nestedparam>
		<aliasparam name="valueDomainID" />
	</mapping>

	<mapping to="VarIDOperand">
		<from>VarID</from>
		<aliasparam />
	</mapping>

	<mapping to="VarIDOperand">
		<from>ComponentID</from>
		<aliasparam name="IDENTIFIER" ordinal="0" />
	</mapping>

	<mapping to="number.NumericUnaryTransformation">
		<from>UnaryNumeric</from>
		<from>UnaryNumericComponent</from>
		<tokens name="op">
			<value>CEIL</value>
			<value>FLOOR</value>
			<value>ABS</value>
			<value>EXP</value>
			<value>LN</value>
			<value>SQRT</value>
		</tokens>
		<tokensetparam name="op" tokenset="NumericUnaryOperator" />
		<exprparam name="expr|exprComponent" />
	</mapping>

	<mapping to="dataset.PivotClauseTransformation">
		<from>PivotOrUnpivotClause</from>
		<tokens name="op">
			<value>PIVOT</value>
		</tokens>
		<aliasparam name="id_" />
		<aliasparam name="mea" />
	</mapping>

	<mapping to="dataset.UnpivotClauseTransformation">
		<from>PivotOrUnpivotClause</from>
		<tokens name="op">
			<value>UNPIVOT</value>
		</tokens>
		<aliasparam name="id_" />
		<aliasparam name="mea" />
	</mapping>

	<mapping to="ops.CheckTransformation">
		<from>ValidationSimple</from>
		<exprparam name="op" />
		<exprparam name="codeErr" />
		<exprparam name="levelCode" />
		<nestedparam name="imbalanceExpr">
			<exprparam />
		</nestedparam>
		<tokensetparam name="output" tokenset="CheckOutput" />
	</mapping>
</parserconfig>
