<?xml version="1.0"?>
<!--

    Copyright Â© 2020 Banca D'Italia

    Licensed under the EUPL, Version 1.2 (the "License");
    You may not use this work except in compliance with the
    License.
    You may obtain a copy of the License at:

    https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/2020-03/EUPL-1.2%20EN.txt

    Unless required by applicable law or agreed to in
    writing, software distributed under the License is
    distributed on an "AS IS" basis,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
    express or implied.

    See the License for the specific language governing
    permissions and limitations under the License.

-->
<parserconfig xmlns="http://oss.bancaditalia.it/vtl" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	
	<package>it.bancaditalia.oss.vtl.impl.transform</package>
	<lexerclass>org.sdmx.vtl.VtlTokens</lexerclass>
	<parserclass>org.sdmx.vtl.Vtl</parserclass>
	
	<roletokens>
		<component>COMPONENT</component>
		<identifier>DIMENSION</identifier>
		<measure>MEASURE</measure>
		<attribute>ATTRIBUTE</attribute>
		<viralattribute>VIRAL</viralattribute>
	</roletokens>
	
	<valuecontexts>
		<integer>SignedInteger,IntegerLiteral</integer>
		<boolean>BooleanLiteral</boolean>
		<string>StringLiteral</string>
		<number>NumberLiteral</number>
		<null>NullLiteral</null>
	</valuecontexts>
	
	<parametertypes>
		<scalar from="ScalarType">
			<typerule name="basicScalarType|valueDomainName" level="toplevel" />
			<defaultrule name="scalarItem" />
		</scalar>
		<component from="ComponentType">
			<rolerule name="componentRole" />
			<scalarrule name="scalarType" />
		</component>
		<dataset from="DatasetType" listrule="compConstraint">
			<namerule name="componentID" level="component" />
			<quantifierrule xsi:type="nestedparam" name="multModifier">
				<tokensetparam ordinal="2" tokenset="ParamMultiplicity" />
			</quantifierrule>
			<componentrule name="componentType" />
		</dataset>
	</parametertypes>

	<tokenset name="ParamMultiplicity" class="it.bancaditalia.oss.vtl.impl.types.statement.QuantifiedComponent$Multiplicity">
		<tokenmapping name="PLUS" value="AT_LEAST_ONE" />
		<tokenmapping name="MUL" value="ANY" />
	</tokenset>
	
	<tokenset name="AssignmentType" class="it.bancaditalia.oss.vtl.impl.types.statement.AssignmentType">
		<tokenmapping name="PUT_SYMBOL" value="PERSISTENT" />
		<tokenmapping name="ASSIGN" value="TEMPORARY" />
	</tokenset>
	
	<tokenset name="Duration" class="it.bancaditalia.oss.vtl.impl.types.data.Frequency">
		<tokenmapping name="A" value="A" />
		<tokenmapping name="S" value="S" />
		<tokenmapping name="Q" value="Q" />
		<tokenmapping name="M" value="M" />
		<tokenmapping name="W" value="W" />
		<tokenmapping name="D" value="D" />
	</tokenset>

	<tokenset name="ChronoField" class="it.bancaditalia.oss.vtl.impl.types.operators.TimeFieldOperator">
		<tokenmapping name="YEAR_OP" value="YEAR" />
		<tokenmapping name="MONTH_OP" value="MONTH" />
		<tokenmapping name="DAYOFMONTH" value="DAY_MONTH" />
		<tokenmapping name="DAYOFYEAR" value="DAY_YEAR" />
	</tokenset>

	<tokenset name="ExistsInMode" class="it.bancaditalia.oss.vtl.impl.transform.bool.ExistsInTransformation$ExistsInMode">
		<tokenmapping name="ALL" value="ALL" />
		<tokenmapping name="TRUE" value="TRUE" />
		<tokenmapping name="FALSE" value="FALSE" />
	</tokenset>

	<tokenset name="HierarchyMode" class="it.bancaditalia.oss.vtl.impl.transform.aggregation.HierarchyTransformation$HierarchyMode">
		<tokenmapping name="NON_NULL" value="NON_NULL" />
		<tokenmapping name="NON_ZERO" value="NON_ZERO" />
		<tokenmapping name="PARTIAL_NULL" value="PARTIAL_NULL" />
		<tokenmapping name="PARTIAL_ZERO" value="PARTIAL_ZERO" />
		<tokenmapping name="ALWAYS_NULL" value="ALWAYS_NULL" />
		<tokenmapping name="ALWAYS_ZERO" value="ALWAYS_ZERO" />
	</tokenset>

	<tokenset name="HierarchyInput" class="it.bancaditalia.oss.vtl.impl.transform.aggregation.HierarchyTransformation$HierarchyInput">
		<tokenmapping name="DATASET" value="DATASET" />
		<tokenmapping name="RULE" value="RULE" />
		<tokenmapping name="RULE_PRIORITY" value="RULE_PRIORITY" />
	</tokenset>

	<tokenset name="HierarchyOutput" class="it.bancaditalia.oss.vtl.impl.transform.aggregation.HierarchyTransformation$HierarchyOutput">
		<tokenmapping name="COMPUTED" value="COMPUTED" />
		<tokenmapping name="ALL" value="ALL" />
	</tokenset>

	<tokenset name="ValidationInput" class="it.bancaditalia.oss.vtl.impl.transform.ops.CheckHierarchyTransformation$Input">
		<tokenmapping name="DATASET" value="DATASET" />
		<tokenmapping name="RULE" value="RULE" />
		<tokenmapping name="RULE_PRIORITY" value="RULE_PRIORITY" />
	</tokenset>

	<tokenset name="ValidationOutput" class="it.bancaditalia.oss.vtl.impl.transform.ops.CheckHierarchyTransformation$Output">
		<tokenmapping name="COMPUTED" value="COMPUTED" />
		<tokenmapping name="ALL" value="ALL" />
	</tokenset>

	<tokenset name="WindowDirection" class="it.bancaditalia.oss.vtl.model.transform.analytic.LimitCriterion$LimitDirection">
		<tokenmapping name="PRECEDING" value="PRECEDING" />
		<tokenmapping name="FOLLOWING" value="FOLLOWING" />
	</tokenset>

	<tokenset name="GroupingMode" class="it.bancaditalia.oss.vtl.model.transform.GroupingClause$GroupingMode">
		<tokenmapping name="BY" value="GROUP_BY" />
		<tokenmapping name="EXCEPT" value="GROUP_EXCEPT" />
		<tokenmapping name="ALL" value="GROUP_ALL" />
	</tokenset>

	<tokenset name="OffsetDirection" class="it.bancaditalia.oss.vtl.impl.transform.aggregation.OffsetTransformation$OffsetDirection">
		<tokenmapping name="LAG" value="LAG" />
		<tokenmapping name="LEAD" value="LEAD" />
	</tokenset>

	<tokenset name="WindowRangeType" class="it.bancaditalia.oss.vtl.model.transform.analytic.WindowCriterion$LimitType">
		<tokenmapping name="RANGE" value="RANGE" />
		<tokenmapping name="DATA" value="DATAPOINTS" />
	</tokenset>

	<tokenset name="OrderingMethod" class="it.bancaditalia.oss.vtl.model.transform.analytic.SortCriterion$SortingMethod">
		<tokenmapping name="ASC" value="ASC" />
		<tokenmapping name="DESC" value="DESC" />
	</tokenset>

	<tokenset name="ValueDomainType" class="it.bancaditalia.oss.vtl.impl.types.domain.Domains">
		<tokenmapping name="STRING" value="STRING" />
		<tokenmapping name="INTEGER" value="INTEGER" />
		<tokenmapping name="NUMBER" value="NUMBER" />
		<tokenmapping name="BOOLEAN" value="BOOLEAN" />
		<tokenmapping name="DATE" value="DATE" />
		<tokenmapping name="TIME" value="TIME" />
		<tokenmapping name="TIME_PERIOD" value="TIME_PERIOD" />
		<tokenmapping name="DURATION" value="DURATION" />
	</tokenset>

	<tokenset name="PeriodDelimiter" class="it.bancaditalia.oss.vtl.impl.transform.time.TimeAggTransformation$PeriodDelimiter">
		<tokenmapping name="FIRST" value="FIRST" />
		<tokenmapping name="LAST" value="LAST" />
	</tokenset>

	<tokenset name="StringOperator" class="it.bancaditalia.oss.vtl.impl.transform.string.StringUnaryTransformation$StringOperator">
		<tokenmapping name="TRIM" value="TRIM" />
		<tokenmapping name="LTRIM" value="LTRIM" />
		<tokenmapping name="RTRIM" value="RTRIM" />
		<tokenmapping name="UCASE" value="UCASE" />
		<tokenmapping name="LCASE" value="LCASE" />
	</tokenset>

	<tokenset name="AggregateOperator" class="it.bancaditalia.oss.vtl.impl.types.operators.AggregateOperator">
		<tokenmapping name="SUM" value="SUM" />
		<tokenmapping name="COUNT" value="COUNT" />
		<tokenmapping name="MAX" value="MAX" />
		<tokenmapping name="MIN" value="MIN" />
		<tokenmapping name="MEDIAN" value="MEDIAN" />
		<tokenmapping name="AVG" value="AVG" />
		<tokenmapping name="VAR_POP" value="VAR_POP" />
		<tokenmapping name="VAR_SAMP" value="VAR_SAMP" />
		<tokenmapping name="STDDEV_POP" value="STDDEV_POP" />
		<tokenmapping name="STDDEV_SAMP" value="STDDEV_SAMP" />
	</tokenset>

	<tokenset name="AnalyticOperator" class="it.bancaditalia.oss.vtl.impl.types.operators.AnalyticOperator">
		<tokenmapping name="SUM" value="SUM" />
		<tokenmapping name="COUNT" value="COUNT" />
		<tokenmapping name="MAX" value="MAX" />
		<tokenmapping name="MIN" value="MIN" />
		<tokenmapping name="MEDIAN" value="MEDIAN" />
		<tokenmapping name="AVG" value="AVG" />
		<tokenmapping name="VAR_POP" value="VAR_POP" />
		<tokenmapping name="VAR_SAMP" value="VAR_SAMP" />
		<tokenmapping name="STDDEV_POP" value="STDDEV_POP" />
		<tokenmapping name="STDDEV_SAMP" value="STDDEV_SAMP" />
		<tokenmapping name="FIRST_VALUE" value="FIRST_VALUE" />
		<tokenmapping name="LAST_VALUE" value="LAST_VALUE" />
	</tokenset>

	<tokenset name="NumericUnaryOperator" class="it.bancaditalia.oss.vtl.impl.transform.number.NumericUnaryTransformation$NumericOperator">
		<tokenmapping name="PLUS" value="UNARY_PLUS" />
		<tokenmapping name="MINUS" value="UNARY_MINUS" />
		<tokenmapping name="CEIL" value="CEIL" />
		<tokenmapping name="FLOOR" value="FLOOR" />
		<tokenmapping name="ABS" value="ABS" />
		<tokenmapping name="EXP" value="EXP" />
		<tokenmapping name="LN" value="LN" />
		<tokenmapping name="SQRT" value="SQRT" />
	</tokenset>

	<tokenset name="ComparisonOperator" class="it.bancaditalia.oss.vtl.impl.types.operators.ComparisonOperator">
		<tokenmapping name="MT" value="GT" />
		<tokenmapping name="ME" value="GE" />
		<tokenmapping name="LE" value="LE" />
		<tokenmapping name="LT" value="LT" />
		<tokenmapping name="EQ" value="EQ" />
		<tokenmapping name="NEQ" value="NE" />
	</tokenset>

	<tokenset name="RulesetMode" class="it.bancaditalia.oss.vtl.model.rules.RuleSet$RuleType">
		<tokenmapping name="MT" value="GT" />
		<tokenmapping name="ME" value="GE" />
		<tokenmapping name="LE" value="LE" />
		<tokenmapping name="LT" value="LT" />
		<tokenmapping name="EQ" value="EQ" />
	</tokenset>

	<tokenset name="SetOperator" class="it.bancaditalia.oss.vtl.impl.transform.ops.SetTransformation$SetOperator">
		<tokenmapping name="UNION" value="UNION" />
		<tokenmapping name="INTERSECT" value="INTERSECT" />
		<tokenmapping name="SETDIFF" value="SETDIFF" />
		<tokenmapping name="SYMDIFF" value="SYMDIFF" />
	</tokenset>

	<tokenset name="DatasetOperator" class="it.bancaditalia.oss.vtl.impl.transform.time.FlowStockTransformation$DatasetOperator">
		<tokenmapping name="FLOW_TO_STOCK" value="FLOW_TO_STOCK" />
		<tokenmapping name="STOCK_TO_FLOW" value="STOCK_TO_FLOW" />
	</tokenset>

	<tokenset name="InOperator" class="it.bancaditalia.oss.vtl.impl.transform.bool.InclusionTransformation$InOperator">
		<tokenmapping name="IN" value="IN" />
		<tokenmapping name="NOT_IN" value="NOTIN" />
	</tokenset>

	<tokenset name="ArithmeticOperator" class="it.bancaditalia.oss.vtl.impl.types.operators.ArithmeticOperator">
		<tokenmapping name="PLUS" value="SUM" />
		<tokenmapping name="MINUS" value="DIFF" />
		<tokenmapping name="MUL" value="MULT" />
		<tokenmapping name="DIV" value="DIV" />
		<tokenmapping name="MOD" value="MOD" />
		<tokenmapping name="POWER" value="POWER" />
		<tokenmapping name="LOG" value="LOG" />
	</tokenset>

	<tokenset name="NumericIntOperator" class="it.bancaditalia.oss.vtl.impl.types.operators.NumericIntOperator">
		<tokenmapping name="ROUND" value="ROUND" />
		<tokenmapping name="TRUNC" value="TRUNC" />
		<tokenmapping name="RANDOM" value="RANDOM" />
	</tokenset>

	<tokenset name="BooleanOperator" class="it.bancaditalia.oss.vtl.impl.transform.bool.BooleanTransformation$BooleanBiOperator">
		<tokenmapping name="AND" value="AND" />
		<tokenmapping name="OR" value="OR" />
		<tokenmapping name="XOR" value="XOR" />
	</tokenset>

	<tokenset name="JoinOperator" class="it.bancaditalia.oss.vtl.impl.transform.ops.JoinTransformation$JoinOperator">
		<tokenmapping name="INNER_JOIN" value="INNER_JOIN" />
		<tokenmapping name="LEFT_JOIN" value="LEFT_JOIN" />
		<tokenmapping name="FULL_JOIN" value="FULL_JOIN" />
		<tokenmapping name="CROSS_JOIN" value="CROSS_JOIN" />
	</tokenset>

	<tokenset name="FillMode" class="it.bancaditalia.oss.vtl.impl.transform.time.FillTimeSeriesTransformation$FillMode">
		<tokenmapping name="ALL" value="ALL" />
		<tokenmapping name="SINGLE" value="SINGLE" />
	</tokenset>

	<tokenset name="CheckOutput" class="it.bancaditalia.oss.vtl.impl.transform.ops.CheckTransformation$CheckOutput">
		<tokenmapping name="ALL" value="ALL" />
		<tokenmapping name="INVALID" value="INVALID" />
	</tokenset>

	<tokenset name="ValidationOutput" class="it.bancaditalia.oss.vtl.impl.transform.ops.CheckHierarchyTransformation$Output">
		<tokenmapping name="INVALID" value="INVALID" />
		<tokenmapping name="ALL" value="ALL" />
		<tokenmapping name="ALL_MEASURES" value="ALL_MEASURES" />
	</tokenset>
	
	<tokenset name="RuleSetType" class="it.bancaditalia.oss.vtl.model.rules.RuleSet$RuleSetType">
		<tokenmapping name="VALUE_DOMAIN" value="VALUE_DOMAIN" />
		<tokenmapping name="VARIABLE" value="VARIABLE" />
	</tokenset>
	
	<tokenset name="RuleSetSign" class="it.bancaditalia.oss.vtl.model.rules.HierarchicalRuleSet$HierarchicalRuleSign">
		<tokenmapping name="PLUS" value="PLUS" />
		<tokenmapping name="MINUS" value="MINUS" />
	</tokenset>
	
	<recursivecontexts>
		<context name="AggregateFunctionsContext" />
		<context name="AggregateFunctionsComponentsContext" />
		<context name="AnalyticFunctionsContext" />
		<context name="AnalyticFunctionsComponentsContext" />
		<context name="CompIdContext" />
		<context name="ComparisonFunctionsContext" />
		<context name="ComparisonFunctionsComponentsContext" />
		<context name="ConditionalFunctionsContext" />
		<context name="ConditionalFunctionsComponentsContext" />
		<context name="DatasetClauseContext" />
		<context name="DefineExpressionContext" />
		<context name="ErCodeContext" />
		<context name="ErLevelContext" />
		<context name="FunctionsExpressionContext" />
		<context name="FunctionsExpressionCompContext" />
		<context name="GenericFunctionsContext" />
		<context name="GenericFunctionsComponentsContext" />
		<context name="HavingClauseContext" />
		<context name="ImbalanceExprContext" />
		<context name="InputParameterTypeContext" />
		<context name="JoinFunctionsContext" />
		<context name="JoinApplyClauseContext" />
		<context name="NumericFunctionsContext" />
		<context name="NumericFunctionsComponentsContext" />
		<context name="OutputParameterTypeContext" />
		<context name="ParameterContext" />
		<context name="ParameterComponentContext" />
		<context name="ParenthesisExprCompContext" />
		<context name="ParenthesisExprContext" />
		<context name="SetFunctionsContext" />
		<context name="SimpleScalarContext" />
		<context name="StringFunctionsContext" />
		<context name="HierarchyFunctionsContext" />
		<context name="StringFunctionsComponentsContext" />
		<context name="TimeFunctionsContext" />
		<context name="TimeFunctionsComponentsContext" />
		<context name="ValidationFunctionsContext" />
		<context name="VarIdExprContext" />
	</recursivecontexts>
	
	<statementdef to="statement.AssignStatement">
		<from>TemporaryAssignment</from>
		<from>PersistAssignment</from>
		<tokensetparam ordinal="2" tokenset="AssignmentType" />
		<aliasparam ordinal="1" level="toplevel" />
		<exprparam ordinal="3" />
	</statementdef>

	<statementdef to="statement.DefineOperatorStatement">
		<from>DefOperator</from>
		<aliasparam name="operatorID" level="toplevel" />
		<listparam name="parameterItem">
			<paramparam>
				<paramname name="varID" level="component" />
				<paramtype name="inputParameterType" />
			</paramparam>
		</listparam>
		<typeparam name="outputParameterType" />
		<exprparam name="expr" />
	</statementdef>	

	<statementdef to="statement.DefineDataPointStatement">
		<from>DefDatapointRuleset</from>
		<aliasparam name="rulesetID" level="toplevel" />
		<nestedparam name="rulesetSignature">
			<tokensetparam tokenset="RuleSetType" ordinal="1" />
			<listparam name="signature">
				<aliasparam name="varID" level="component" />
			</listparam>
			<listparam name="signature">
				<aliasparam name="alias" level="component" />
			</listparam>
		</nestedparam>
		<nestedparam name="ruleClauseDatapoint">
			<listparam name="ruleItemDatapoint">
				<customparam class="it.bancaditalia.oss.vtl.impl.types.statement.DataPointRuleImpl">
					<aliasparam name="ruleName" level="component" />
					<exprparam name="antecedentContiditon" />
					<exprparam name="consequentCondition" />
					<valueparam name="erCode" />
					<valueparam name="erLevel" />
				</customparam>
			</listparam>
		</nestedparam>
	</statementdef>	

	<statementdef to="statement.DefineHierarchyStatement">
		<from>DefHierarchical</from>
		<aliasparam name="rulesetID" level="toplevel" />
		<nestedparam name="hierRuleSignature">
			<tokensetparam tokenset="RuleSetType" ordinal="1" />
			<aliasparam name="IDENTIFIER" level="toplevel" />
			<nestedparam name="valueDomainSignature">
				<listparam name="signature">
					<aliasparam name="varID" level="component" />
				</listparam>
				<listparam name="signature">
					<aliasparam name="alias" level="toplevel" />
				</listparam>
			</nestedparam>
		</nestedparam>
		<nestedparam name="ruleClauseHierarchical">
			<listparam name="ruleItemHierarchical">
				<customparam class="it.bancaditalia.oss.vtl.impl.types.statement.HierarchicalRuleImpl">
					<aliasparam name="ruleName" level="component" />
					<nestedparam name="codeItemRelation">
						<exprparam name="exprComponent" />
						<stringparam name="codetemRef" />
						<tokensetparam tokenset="RulesetMode" name="comparisonOperand" />
						<listparam name="codeItemRelationClause">
							<stringparam name="rightCodeItem" />
						</listparam>
						<listparam name="codeItemRelationClause">
							<tokensetparam tokenset="RuleSetSign" name="opAdd" />
						</listparam>
						<listparam name="codeItemRelationClause">
							<exprparam name="rightCondition" />
						</listparam>
					</nestedparam>
					<valueparam name="erCode" />
					<valueparam name="erLevel" />
				</customparam>
			</listparam>
		</nestedparam>
	</statementdef>	

	<mapping to="time.CurrentDateOperand">
		<from>CurrentDateAtom</from>
	</mapping>

	<mapping to="ops.CheckHierarchyTransformation">
		<from>ValidateHRruleset</from>
		<exprparam name="op" />
		<aliasparam name="hrName" level="toplevel" />
		<nestedparam name="conditionClause">
			<listparam name="componentID">
				<aliasparam level="component" />
			</listparam>
		</nestedparam>
		<aliasparam name="componentID" level="component" />
		<tokensetparam name="validationMode" tokenset="HierarchyMode" />
		<tokensetparam name="inputMode" tokenset="ValidationInput" />
		<tokensetparam name="validationOutput" tokenset="ValidationOutput" />
	</mapping>

	<mapping to="ops.CheckDataPointTransformation">
		<from>ValidateDPruleset</from>
		<exprparam name="op" />
		<aliasparam name="dpName" level="toplevel" />
		<listparam name="componentID">
			<aliasparam level="component" />
		</listparam>
		<tokensetparam name="validationOutput" tokenset="ValidationOutput" />
	</mapping>

	<mapping to="aggregation.HierarchyTransformation">
		<from>HierarchyOperators</from>
		<exprparam name="expr" />
		<aliasparam name="hrName" level="toplevel" />
		<nestedparam name="conditionClause">
			<listparam name="componentID">
				<aliasparam level="component" />
			</listparam>
		</nestedparam>
		<aliasparam name="ruleComponent" level="component" />
		<tokensetparam name="validationMode" tokenset="HierarchyMode" />
		<tokensetparam name="inputModeHierarchy" tokenset="HierarchyInput" />
		<tokensetparam name="outputModeHierarchy" tokenset="HierarchyOutput" />
	</mapping>

	<mapping to="aggregation.SimpleAnalyticTransformation">
		<from>AnSimpleFunction</from>
		<tokensetparam name="op" tokenset="AnalyticOperator" />
		<exprparam name="expr" />
		<nestedparam name="partitionByClause">
			<listparam name="componentID">
				<aliasparam level="component" />
			</listparam>
		</nestedparam>
		<nestedparam name="orderByClause">
			<listparam name="orderByItem">
				<customparam class="it.bancaditalia.oss.vtl.impl.transform.aggregation.AnalyticTransformation$OrderByItem">
					<aliasparam name="componentID" level="component" />
					<tokensetparam tokenset="OrderingMethod" />
				</customparam>
			</listparam>
		</nestedparam>
		<customparam name="windowingClause" class="it.bancaditalia.oss.vtl.impl.transform.util.WindowCriterionImpl">
			<tokensetparam tokenset="WindowRangeType" />
			<caseparam name="from_" class="it.bancaditalia.oss.vtl.impl.transform.util.LimitClause">
				<case>
					<context context="SignedInteger" ordinal="1" />
					<tokensetparam name="dir" tokenset="WindowDirection" />
					<valueparam ordinal="1" />
				</case>
				<case>
					<tokens ordinal="1">
						<value>UNBOUNDED</value>
					</tokens>
					<tokensetparam name="dir" tokenset="WindowDirection" />
				</case>
			</caseparam>
			<caseparam name="to_" class="it.bancaditalia.oss.vtl.impl.transform.util.LimitClause">
				<case>
					<context context="SignedInteger" ordinal="1" />
					<tokensetparam name="dir" tokenset="WindowDirection" />
					<valueparam ordinal="1" />
				</case>
				<case>
					<tokens ordinal="1">
						<value>UNBOUNDED</value>
					</tokens>
					<tokensetparam name="dir" tokenset="WindowDirection" />
				</case>
			</caseparam>
		</customparam>
	</mapping>

	<mapping to="aggregation.OffsetTransformation">
		<from>LagOrLeadAn</from>
		<tokensetparam name="op" tokenset="OffsetDirection" />
		<exprparam name="expr" />
		<valueparam name="signedInteger" />
		<valueparam name="defaultValue" />
		<nestedparam name="partitionByClause">
			<listparam name="componentID">
				<aliasparam level="component" />
			</listparam>
		</nestedparam>
		<nestedparam name="orderByClause">
			<listparam name="orderByItem">
				<customparam class="it.bancaditalia.oss.vtl.impl.transform.aggregation.AnalyticTransformation$OrderByItem">
					<aliasparam name="componentID" level="component" />
					<tokensetparam tokenset="OrderingMethod" />
				</customparam>
			</listparam>
		</nestedparam>
	</mapping>

	<mapping to="aggregation.OffsetTransformation">
		<from>LagOrLeadAnComponent</from>
		<tokensetparam name="op" tokenset="OffsetDirection" />
		<exprparam name="exprComponent" />
		<valueparam name="signedInteger" />
		<valueparam name="defaultValue" />
		<nestedparam name="partitionByClause">
			<listparam name="componentID">
				<aliasparam level="component" />
			</listparam>
		</nestedparam>
		<nestedparam name="orderByClause">
			<listparam name="orderByItem">
				<customparam class="it.bancaditalia.oss.vtl.impl.transform.aggregation.AnalyticTransformation$OrderByItem">
					<aliasparam name="componentID" level="component" />
					<tokensetparam tokenset="OrderingMethod" />
				</customparam>
			</listparam>
		</nestedparam>
	</mapping>

	<mapping to="aggregation.RatioToReportTransformation">
		<from>RatioToReportAn</from>
		<exprparam name="expr" />
		<nestedparam name="partitionByClause">
			<listparam name="componentID">
				<aliasparam level="component" />
			</listparam>
		</nestedparam>
	</mapping>

	<mapping to="aggregation.RatioToReportTransformation">
		<from>RatioToReportAnComponent</from>
		<exprparam name="exprComponent" />
		<nestedparam name="partitionByClause">
			<listparam name="componentID">
				<aliasparam level="component" />
			</listparam>
		</nestedparam>
	</mapping>

	<mapping to="aggregation.SimpleAnalyticTransformation">
		<from>AnSimpleFunctionComponent</from>
		<tokensetparam name="op" tokenset="AnalyticOperator" />
		<exprparam name="exprComponent" />
		<nestedparam name="partitionByClause">
			<listparam name="componentID">
				<aliasparam level="component" />
			</listparam>
		</nestedparam>
		<nestedparam name="orderByClause">
			<listparam name="orderByItem">
				<customparam class="it.bancaditalia.oss.vtl.impl.transform.aggregation.AnalyticTransformation$OrderByItem">
					<aliasparam name="componentID" level="component" />
					<tokensetparam tokenset="OrderingMethod" />
				</customparam>
			</listparam>
		</nestedparam>
		<customparam name="windowingClause" class="it.bancaditalia.oss.vtl.impl.transform.util.WindowCriterionImpl">
			<tokensetparam tokenset="WindowRangeType" />
			<caseparam name="from_" class="it.bancaditalia.oss.vtl.impl.transform.util.LimitClause">
				<case>
					<context context="SignedInteger" ordinal="1" />
					<tokensetparam name="dir" tokenset="WindowDirection" />
					<valueparam ordinal="1" />
				</case>
				<case>
					<tokens ordinal="1">
						<value>UNBOUNDED</value>
					</tokens>
					<tokensetparam name="dir" tokenset="WindowDirection" />
				</case>
			</caseparam>
			<caseparam name="to_" class="it.bancaditalia.oss.vtl.impl.transform.util.LimitClause">
				<case>
					<context context="SignedInteger" ordinal="1" />
					<tokensetparam name="dir" tokenset="WindowDirection" />
					<valueparam ordinal="1" />
				</case>
				<case>
					<tokens ordinal="1">
						<value>UNBOUNDED</value>
					</tokens>
					<tokensetparam name="dir" tokenset="WindowDirection" />
				</case>
			</caseparam>
		</customparam>
	</mapping>

	<mapping to="aggregation.RankTransformation">
		<from>RankAnComponent</from>
		<nestedparam name="partitionByClause">
			<listparam name="componentID">
				<aliasparam level="component" />
			</listparam>
		</nestedparam>
		<nestedparam name="orderByClause">
			<listparam name="orderByItem">
				<customparam class="it.bancaditalia.oss.vtl.impl.transform.aggregation.AnalyticTransformation$OrderByItem">
					<aliasparam name="componentID" level="component" />
					<tokensetparam tokenset="OrderingMethod" />
				</customparam>
			</listparam>
		</nestedparam>
	</mapping>

	<mapping to="aggregation.AggregateTransformation">
		<from>AggrDataset</from>
		<tokensetparam name="op" tokenset="AggregateOperator" />
		<exprparam name="expr" />
		<nestedparam name="groupingClause" type="groupby">
			<caseparam class="it.bancaditalia.oss.vtl.impl.transform.GroupingClauseImpl">
				<case>
					<tokens ordinal="2">
						<value>BY</value>
						<value>EXCEPT</value>
					</tokens>
					<tokensetparam name="op" tokenset="GroupingMode" />
					<listparam name="componentID">
						<aliasparam level="component" />
					</listparam>
					<valueparam name="STRING_CONSTANT" />
				</case>
				<case>
					<tokens ordinal="2">
						<value>ALL</value>
					</tokens>
					<tokensetparam ordinal="2" tokenset="GroupingMode" />
					<nullparam />
					<valueparam name="STRING_CONSTANT" />
				</case>
			</caseparam>
		</nestedparam>
		<exprparam name="havingClause" />
	</mapping>

	<mapping to="aggregation.AggregateTransformation">
		<from>AggrComp</from>
		<tokensetparam name="op" tokenset="AggregateOperator" />
		<exprparam name="exprComponent" />
		<nullparam type="groupby" />
		<nullparam />
	</mapping>

	<mapping to="aggregation.AggregateTransformation">
		<from>CountAggrComp</from>
		<nullparam type="groupby" />
		<nullparam />
	</mapping>

	<mapping to="dataset.AggrClauseTransformation">
		<from>AggrClause</from>
		<tokens name="groupingClause">
			<value>BY</value>
			<value>EXCEPT</value>
		</tokens>
		<nestedparam name="aggregateClause">
			<listparam name="aggrFunctionClause">
				<customparam class="it.bancaditalia.oss.vtl.impl.transform.dataset.AggrClauseTransformation$AggrClauseItem">
					<roleparam name="componentRole" />
					<aliasparam name="componentID" level="component" />
					<exprparam name="aggrOperators" />
				</customparam>
			</listparam>
		</nestedparam>
		<nestedparam name="groupingClause" type="groupby">
			<customparam class="it.bancaditalia.oss.vtl.impl.transform.GroupingClauseImpl">
				<tokensetparam name="op" tokenset="GroupingMode" />
				<listparam name="componentID">
					<aliasparam level="component" />
				</listparam>
				<valueparam name="STRING_CONSTANT" />
			</customparam>
		</nestedparam>
		<exprparam name="havingClause" />
	</mapping>

	<mapping to="dataset.AggrClauseTransformation">
		<from>AggrClause</from>
		<tokens name="groupingClause">
			<value>ALL</value>
		</tokens>
		<nestedparam name="aggregateClause">
			<listparam name="aggrFunctionClause">
				<customparam class="it.bancaditalia.oss.vtl.impl.transform.dataset.AggrClauseTransformation$AggrClauseItem">
					<roleparam name="componentRole" />
					<aliasparam name="componentID" level="component" />
					<exprparam name="aggrOperators" />
				</customparam>
			</listparam>
		</nestedparam>
		<nestedparam name="groupingClause" type="groupby">
			<customparam class="it.bancaditalia.oss.vtl.impl.transform.GroupingClauseImpl">
				<tokensetparam ordinal="2" tokenset="GroupingMode" />
				<nullparam />
				<valueparam name="STRING_CONSTANT" />
			</customparam>
		</nestedparam>
		<exprparam name="havingClause" />
	</mapping>

	<mapping to="dataset.KeepClauseTransformation">
		<from>KeepOrDropClause</from>
		<tokens name="op">
			<value>KEEP</value>
		</tokens>
		<listparam name="componentID">
			<aliasparam level="component" />
		</listparam>
	</mapping>

	<mapping to="dataset.DropClauseTransformation">
		<from>KeepOrDropClause</from>
		<tokens name="op">
			<value>DROP</value>
		</tokens>
		<listparam name="componentID">
			<aliasparam level="component" />
		</listparam>
	</mapping>

	<mapping to="dataset.CalcClauseTransformation">
		<from>CalcClause</from>
		<listparam name="calcClauseItem">
			<exprparam />
		</listparam>
	</mapping>

	<mapping to="dataset.CalcClauseTransformation$CalcClauseItem">
		<from>CalcClauseItem</from>
		<roleparam name="componentRole" />
		<aliasparam name="componentID" level="component" />
		<exprparam name="exprComponent" />
	</mapping>

	<mapping to="ops.JoinTransformation">
		<from>JoinExpr</from>
		<tokens name="joinKeyword">
			<value>INNER_JOIN</value>
			<value>LEFT_JOIN</value>
		</tokens>
		<tokensetparam name="joinKeyword" tokenset="JoinOperator" />
		<nestedparam name="joinClause">
			<listparam name="joinClauseItem">
				<customparam class="it.bancaditalia.oss.vtl.impl.transform.ops.JoinTransformation$JoinOperand">
					<exprparam name="expr" />
					<aliasparam name="alias" level="toplevel" />
				</customparam>
			</listparam>
			<listparam name="componentID">
				<aliasparam level="component" />
			</listparam>
		</nestedparam>
		<nestedparam name="joinBody">
			<exprparam name="filterClause" />
			<exprparam name="joinApplyClause" />
			<exprparam name="calcClause" />
			<exprparam name="aggrClause" />
			<exprparam name="keepOrDropClause" />
			<exprparam name="renameClause" />
		</nestedparam>
	</mapping>

	<mapping to="ops.JoinTransformation">
		<from>JoinExpr</from>
		<tokens name="joinKeyword">
			<value>FULL_JOIN</value>
			<value>CROSS_JOIN</value>
		</tokens>
		<tokensetparam name="joinKeyword" tokenset="JoinOperator" />
		<nestedparam name="joinClauseWithoutUsing">
			<listparam name="joinClauseItem">
				<customparam class="it.bancaditalia.oss.vtl.impl.transform.ops.JoinTransformation$JoinOperand">
					<exprparam name="expr" />
					<aliasparam name="alias" level="toplevel" />
				</customparam>
			</listparam>
			<nullparam />
		</nestedparam>
		<nestedparam name="joinBody">
			<exprparam name="filterClause" />
			<exprparam name="joinApplyClause" />
			<exprparam name="calcClause" />
			<exprparam name="aggrClause" />
			<exprparam name="keepOrDropClause" />
			<exprparam name="renameClause" />
		</nestedparam>
	</mapping>

	<mapping to="ops.SetTransformation">
		<from>UnionAtom</from>
		<tokensetparam tokenset="SetOperator" />
		<listparam name="expr">
			<exprparam />
		</listparam>
	</mapping>

	<mapping to="ops.SetTransformation">
		<from>IntersectAtom</from>
		<tokensetparam tokenset="SetOperator" />
		<listparam name="expr">
			<exprparam />
		</listparam>
	</mapping>

	<mapping to="ops.SetTransformation">
		<from>SetOrSYmDiffAtom</from>
		<tokensetparam tokenset="SetOperator" />
		<listparam name="expr">
			<exprparam />
		</listparam>
	</mapping>

	<mapping to="ops.JoinTransformation$JoinOperand">
		<from>JoinClauseItem</from>
		<exprparam name="expr" />
		<aliasparam name="alias" level="toplevel" />
	</mapping>

	<mapping to="dataset.BracketTransformation">
		<from>ClauseExpr</from>
		<exprparam name="dataset" />
		<exprparam name="clause" />
		<nullparam />
	</mapping>

	<mapping to="time.PeriodIndicatorTransformation">
		<from>PeriodAtom</from>
		<from>PeriodAtomComponent</from>
		<exprparam name="expr|exprComponent" />
	</mapping>

	<mapping to="bool.ConditionalTransformation">
		<from>IfExpr</from>
		<from>IfExprComp</from>
		<exprparam name="conditionalExpr" />
		<exprparam name="thenExpr" />
		<exprparam name="elseExpr" />
	</mapping>

	<mapping to="bool.CaseWhenTransformation">
		<from>CaseExpr</from>
		<from>CaseExprComp</from>
		<listparam name="condExpr">
			<exprparam />
		</listparam>
		<listparam name="thenExpr">
			<exprparam />
		</listparam>
		<exprparam name="elseExpr" />
	</mapping>

	<mapping to="bool.BetweenTransformation">
		<from>BetweenAtom</from>
		<from>BetweenAtomComponent</from>
		<exprparam name="op" />
		<exprparam name="from_" />
		<exprparam name="to_" />
	</mapping>

	<mapping to="time.FillTimeSeriesTransformation">
		<from>FillTimeAtom</from>
		<exprparam name="expr" />
		<tokensetparam tokenset="FillMode" name="op" />
	</mapping>

	<mapping to="time.DateAddTransformation">
		<from>DateAddAtom</from>
		<from>DateAddAtomComponent</from>
		<exprparam name="op" />
		<exprparam name="shiftNumber" />
		<exprparam name="periodInd" />
	</mapping>

	<mapping to="time.DateDiffTransformation">
		<from>DateDiffAtom</from>
		<from>DateDiffAtomComponent</from>
		<exprparam name="dateFrom" />
		<exprparam name="dateTo" />
	</mapping>

	<mapping to="time.TimeShiftTransformation">
		<from>TimeShiftAtom</from>
		<exprparam name="expr" />
		<valueparam name="signedInteger" />
	</mapping>

	<mapping to="time.TimeAggTransformation">
		<from>TimeAggAtom</from>
		<from>TimeAggAtomComponent</from>
		<nestedparam name="op">
			<exprparam name="expr|exprComponent" />
		</nestedparam>
		<stringparam name="periodIndTo" />
		<stringparam name="periodIndFrom" />
		<tokensetparam name="delim" tokenset="PeriodDelimiter" />
	</mapping>

	<mapping to="dataset.BracketTransformation">
		<from>MembershipExpr</from>
		<exprparam name="expr" />
		<nullparam />
		<aliasparam name="simpleComponentId" level="component" />
	</mapping>

	<mapping to="dataset.SubspaceClauseTransformation">
		<from>SubspaceClause</from>
		<mapparam name="subspaceClauseItem">
			<key>
				<aliasparam name="componentID" level="component" />
			</key>
			<value>
				<valueparam name="scalarItem" />
			</value>
		</mapparam>
	</mapping>

	<mapping to="dataset.RenameClauseTransformation">
		<from>RenameClause</from>
		<mapparam name="renameClauseItem">
			<key>
				<aliasparam name="fromName" level="component" />
			</key>
			<value>
				<aliasparam name="toName" level="component" />
			</value>
		</mapparam>
	</mapping>

	<mapping to="dataset.FilterClauseTransformation">
		<from>FilterClause</from>
		<exprparam name="exprComponent" />
	</mapping>

	<mapping to="ops.CallTransformation">
		<from>CallComponent</from>
		<aliasparam name="operatorID" level="toplevel" />
		<listparam name="parameterComponent">
			<exprparam />
		</listparam>
	</mapping>

	<mapping to="ops.CallTransformation">
		<from>CallDataset</from>
		<aliasparam name="operatorID" level="toplevel" />
		<listparam name="parameter">
			<exprparam />
		</listparam>
	</mapping>

	<mapping to="string.StringUnaryTransformation">
		<from>UnaryStringFunction</from>
		<from>UnaryStringFunctionComponent</from>
		<tokens name="op">
			<value>TRIM</value>
			<value>LTRIM</value>
			<value>RTRIM</value>
			<value>UCASE</value>
			<value>LCASE</value>
		</tokens>
		<tokensetparam tokenset="StringOperator" name="op" />
		<exprparam name="expr|exprComponent" />
	</mapping>

	<mapping to="string.StrlenTransformation">
		<from>UnaryStringFunction</from>
		<from>UnaryStringFunctionComponent</from>
		<tokens name="op">
			<value>LEN</value>
		</tokens>
		<exprparam name="expr|exprComponent" />
	</mapping>

	<mapping to="bool.ExistsInTransformation">
		<from>ExistInAtom</from>
		<exprparam name="left" />
		<exprparam name="right" />
		<tokensetparam tokenset="ExistsInMode" name="retainType" />
	</mapping>

	<mapping to="ConstantOperand">
		<from>ConstantExpr</from>
		<from>ConstantExprComp</from>
		<valueparam name="constant" />
	</mapping>

	<mapping to="ConstantOperand">
		<from>Constant</from>
		<valueparam />
	</mapping>

	<mapping to="ops.CastTransformation">
		<from>CastExprDataset</from>
		<tokens name="basicScalarType">
			<value>STRING</value>
			<value>INTEGER</value>
			<value>NUMBER</value>
			<value>BOOLEAN</value>
			<value>DATE</value>
			<value>TIME</value>
			<value>TIME_PERIOD</value>
			<value>DURATION</value>
			<value>SCALAR</value>
		</tokens>
		<exprparam name="expr" />
		<tokensetparam name="basicScalarType" tokenset="ValueDomainType" />
		<stringparam name="STRING_CONSTANT" />
	</mapping>

	<mapping to="ops.CastTransformation">
		<from>CastExprDataset</from>
		<exprparam name="expr" />
		<aliasparam name="valueDomainName" level="toplevel" />
		<stringparam name="STRING_CONSTANT" />
	</mapping>

	<mapping to="ops.CastTransformation">
		<from>CastExprComponent</from>
		<tokens name="basicScalarType">
			<value>STRING</value>
			<value>INTEGER</value>
			<value>NUMBER</value>
			<value>BOOLEAN</value>
			<value>DATE</value>
			<value>TIME</value>
			<value>TIME_PERIOD</value>
			<value>DURATION</value>
			<value>SCALAR</value>
		</tokens>
		<exprparam name="exprComponent" />
		<tokensetparam name="basicScalarType" tokenset="ValueDomainType" />
		<stringparam name="STRING_CONSTANT" />
	</mapping>

	<mapping to="ops.CastTransformation">
		<from>CastExprComponent</from>
		<exprparam name="exprComponent" />
		<aliasparam name="valueDomainName" level="toplevel" />
		<stringparam name="STRING_CONSTANT" />
	</mapping>

	<mapping to="number.NumericUnaryTransformation">
		<from>UnaryExpr</from>
		<from>UnaryExprComp</from>
		<tokens name="op">
			<value>PLUS</value>
			<value>MINUS</value>
		</tokens>
		<tokensetparam name="op" tokenset="NumericUnaryOperator" />
		<exprparam name="right" />
	</mapping>

	<mapping to="bool.NotTransformation">
		<from>UnaryExpr</from>
		<from>UnaryExprComp</from>
		<tokens name="op">
			<value>NOT</value>
		</tokens>
		<exprparam name="right" />
	</mapping>

	<mapping to="bool.ComparisonTransformation">
		<from>ComparisonExpr</from>
		<from>ComparisonExprComp</from>
		<tokensetparam name="comparisonOperand" tokenset="ComparisonOperator" />
		<exprparam name="left" />
		<exprparam name="right" />
	</mapping>

	<mapping to="string.InStrTransformation">
		<from>InstrAtom</from>
		<from>InstrAtomComponent</from>
		<exprparam name="expr|exprComponent" ordinal="0" />
		<exprparam name="pattern" />
		<nestedparam name="startParameter">
			<exprparam name="expr|exprComponent" />
		</nestedparam>
		<nestedparam name="occurrenceParameter">
			<exprparam name="expr|exprComponent" />
		</nestedparam>
	</mapping>

	<mapping to="string.MatchTransformation">
		<from>CharsetMatchAtom</from>
		<from>CharsetMatchAtomComponent</from>
		<exprparam name="op" />
		<exprparam name="pattern" />
	</mapping>

	<mapping to="bool.IsNullTransformation">
		<from>IsNullAtom</from>
		<from>IsNullAtomComponent</from>
		<exprparam name="expr|exprComponent" />
	</mapping>

	<mapping to="bool.NvlTransformation">
		<from>NvlAtom</from>
		<from>NvlAtomComponent</from>
		<exprparam name="left" />
		<exprparam name="right" />
	</mapping>

	<mapping to="string.ReplaceTransformation">
		<from>ReplaceAtom</from>
		<from>ReplaceAtomComponent</from>
		<exprparam name="expr|exprComponent" ordinal="0" />
		<exprparam name="param" />
		<nestedparam name="optionalExpr|optionalExprComponent">
			<exprparam name="expr|exprComponent" />
		</nestedparam>
	</mapping>

	<mapping to="string.SubstrTransformation">
		<from>SubstrAtom</from>
		<from>SubstrAtomComponent</from>
		<exprparam name="expr|exprComponent" />
		<nestedparam name="startParameter">
			<exprparam name="expr|exprComponent" />
		</nestedparam>
		<nestedparam name="endParameter">
			<exprparam name="expr|exprComponent" />
		</nestedparam>
	</mapping>

	<mapping to="time.ExtractTimeFieldTransformation">
		<from>YearAtomComponent</from>
		<from>MonthAtomComponent</from>
		<from>DayOfMonthAtomComponent</from>
		<from>DayOfYearAtomComponent</from>
		<tokensetparam ordinal="1" tokenset="ChronoField" />
		<exprparam name="exprComponent" />
	</mapping>

	<mapping to="number.ArithmeticTransformation">
		<from>ArithmeticExprOrConcat</from>
		<from>ArithmeticExprOrConcatComp</from>
		<tokens name="op">
			<value>PLUS</value>
			<value>MINUS</value>
		</tokens>
		<tokensetparam name="op" tokenset="ArithmeticOperator" />
		<exprparam name="left" />
		<exprparam name="right" />
	</mapping>

	<mapping to="number.ArithmeticTransformation">
		<from>BinaryNumeric</from>
		<from>BinaryNumericComponent</from>
		<tokens name="op">
			<value>MOD</value>
			<value>LOG</value>
			<value>POWER</value>
		</tokens>
		<tokensetparam name="op" tokenset="ArithmeticOperator" />
		<exprparam name="left" />
		<exprparam name="right" />
	</mapping>

	<mapping to="number.NumericIntTransformation">
		<from>UnaryWithOptionalNumeric</from>
		<from>UnaryWithOptionalNumericComponent</from>
		<tokens name="op">
			<value>ROUND</value>
			<value>TRUNC</value>
			<value>RANDOM</value>
		</tokens>
		<tokensetparam name="op" tokenset="NumericIntOperator" />
		<exprparam name="expr|exprComponent" />
		<nestedparam name="optionalExpr|optionalExprComponent">
			<exprparam name="expr|exprComponent" />
		</nestedparam>
	</mapping>

	<mapping to="bool.BooleanTransformation">
		<from>BooleanExpr</from>
		<from>BooleanExprComp</from>
		<tokensetparam name="op" tokenset="BooleanOperator" />
		<exprparam name="left" />
		<exprparam name="right" />
	</mapping>

	<mapping to="string.ConcatTransformation">
		<from>ArithmeticExprOrConcat</from>
		<from>ArithmeticExprOrConcatComp</from>
		<tokens name="op">
			<value>CONCAT</value>
		</tokens>
		<exprparam name="left" />
		<exprparam name="right" />
	</mapping>

	<mapping to="number.ArithmeticTransformation">
		<from>ArithmeticExpr</from>
		<from>ArithmeticExprComp</from>
		<tokensetparam name="op" tokenset="ArithmeticOperator" />
		<exprparam name="left" />
		<exprparam name="right" />
	</mapping>

	<mapping to="time.FlowStockTransformation">
		<from>FlowAtom</from>
		<tokensetparam name="op" tokenset="DatasetOperator" />
		<exprparam name="expr" />
	</mapping>

	<mapping to="bool.InclusionTransformation">
		<from>InNotInExpr</from>
		<from>InNotInExprComp</from>
		<tokensetparam name="op" tokenset="InOperator" />
		<exprparam name="left" />
		<nestedparam name="lists">
			<listparam name="scalarItem">
				<valueparam />
			</listparam>
		</nestedparam>
		<aliasparam name="valueDomainID" level="toplevel" />
	</mapping>

	<mapping to="VarIDOperand">
		<from>VarID</from>
		<aliasparam level="component" />
	</mapping>

	<mapping to="VarIDOperand">
		<from>ComponentID</from>
		<aliasparam name="IDENTIFIER" ordinal="0" level="component" />
	</mapping>

	<mapping to="number.NumericUnaryTransformation">
		<from>UnaryNumeric</from>
		<from>UnaryNumericComponent</from>
		<tokens name="op">
			<value>CEIL</value>
			<value>FLOOR</value>
			<value>ABS</value>
			<value>EXP</value>
			<value>LN</value>
			<value>SQRT</value>
		</tokens>
		<tokensetparam name="op" tokenset="NumericUnaryOperator" />
		<exprparam name="expr|exprComponent" />
	</mapping>

	<mapping to="dataset.PivotClauseTransformation">
		<from>PivotOrUnpivotClause</from>
		<tokens name="op">
			<value>PIVOT</value>
		</tokens>
		<aliasparam name="id_" level="component" />
		<aliasparam name="mea" level="component" />
	</mapping>

	<mapping to="dataset.UnpivotClauseTransformation">
		<from>PivotOrUnpivotClause</from>
		<tokens name="op">
			<value>UNPIVOT</value>
		</tokens>
		<aliasparam name="id_" level="component" />
		<aliasparam name="mea" level="component" />
	</mapping>

	<mapping to="ops.CheckTransformation">
		<from>ValidationSimple</from>
		<exprparam name="op" />
		<exprparam name="codeErr" />
		<exprparam name="levelCode" />
		<nestedparam name="imbalanceExpr">
			<exprparam />
		</nestedparam>
		<tokensetparam name="output" tokenset="CheckOutput" />
	</mapping>
</parserconfig>
